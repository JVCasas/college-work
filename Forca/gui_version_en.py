from tkinter import *
from tkinter import ttk
import tkinter as tk
from tkinter.messagebox import Message
from PIL import Image, ImageTk
import random
import unicodedata
import os

root = Tk()

def check_file(target):
    """
    Checks the existence of the database file, and if it exists, searches for inconsistencies.

    Args:
        target (str): The name of the target file.

    Returns:
        tuple: A tuple containing a message (str) indicating error or success and a boolean value (bool).
               The boolean value is False if there are inconsistencies in the file or if it does not exist,
               and True if everything is in order.
    """

    validity = True
    message = ''
    try:
        empty_file = False
        extra_hashtag = False
        missing_hashtag = False
        invalid_character = False
        empty_line = False
        words_without_theme = False
        theme_without_words = False

        with open(target, 'r', encoding='utf-8') as file:
            if os.path.getsize(target) == 0:
                empty_file = True
            for line in file:
                hashtags = 0
                if line == '\n':
                    empty_line = True
                for char in line:
                    if char == '#':
                        hashtags += 1
                    if not char.isalpha() and char not in '- #,' and char != '\n':
                        invalid_character = True
                if hashtags > 1:
                    extra_hashtag = True
                if hashtags < 1 and not empty_line:
                    missing_hashtag = True
                if hashtags == 1:
                    checker = line.split('#')
                    if checker[0] == '':
                        words_without_theme = True
                    if checker[1] == '' or checker[1] == '\n':
                        theme_without_words = True

        if empty_file:
            message += 'Error: File "Biblio.txt" is empty.\n'
            validity = False
        if extra_hashtag:
            message += 'Error: Extra theme/words separator (#).\n'
            validity = False
        if missing_hashtag:
            message += 'Error: Missing theme/words separator (#).\n'
            validity = False
        if invalid_character:
            message += 'Error: Invalid character in the library.\n'
            validity = False
        if empty_line:
            message += 'Error: Empty line in the library.\n'
            validity = False
        if theme_without_words:
            message += 'Error: Theme without words.\n'
            validity = False
        if words_without_theme:
            message += 'Error: Words without a theme.\n'
            validity = False
        if validity:
            message += 'Library OK'

        return message, validity

    except FileNotFoundError:
        validity = False
        message += 'Error: File "Biblio.txt" not found.\n'
        return message, validity


class Challenge:  # Class that generates a challenge object, containing properties related to the word to be guessed
    
    def __init__(self, theme, word):
        self.word = word  # Receives the original word
        self.theme = theme  # Receives the theme of the word
        self.length = len(word.replace(' ', ''))  # Receives the word length, excluding spaces for compound words
        self.reference = self.generate_reference(self.word)  # Receives the processed word for comparison with guesses
        self.shadow = self.generate_shadow()  # Receives the initial hidden word representation
        self.errors = list()  # List to store incorrect guesses

    def generate_shadow(self):  # Function to generate a list analogous to the original word to be edited based on correct guesses
        self.shadow = ['_'] * len(self.word)
        for i in range(len(self.word)):
            if self.word[i] == ' ':
                self.shadow[i] = ' '
        return self.shadow

    @staticmethod
    def generate_reference(word):  # Function to normalize a string, removing accents and converting it to lowercase (comparison standard)
        comparator = word.lower()
        comparator = unicodedata.normalize('NFD', comparator)
        comparator = comparator.encode("ascii", "ignore")
        comparator = comparator.decode("utf-8")
        return comparator


class Database:  # Class responsible for generating a word library from a txt file, for the generation of challenge objects
    
    def __init__(self, file):
        self.database, self.database_keys = self.generate_database(file)

    def generate_challenge(self):  # Function that returns a challenge object using the library and list generated by this class
        theme = random.choice(self.database_keys)
        word = random.choice(self.database[theme])
        return Challenge(theme, word)

    @staticmethod
    def generate_database(database_file):  # Function to open a txt file, read it, and generate a library and a list
        with open(database_file, 'r', encoding="utf-8") as data:
            dictionary = {}
            themes = []
            for line in data:
                theme, words = line.split('#')
                words = words.replace('\n', '')
                words = words.split(',')
                dictionary[theme] = words
        
        for key in dictionary.keys():
            themes.append(key)
            
        return dictionary, themes

class Functions:  # Class responsible for functions
    
    def exit_game(self):  # Function that closes the game
        self.root.destroy()

    def generate_squares(self):  # Function that generates a visual element analogous to the original word
        x0 = 25
        x1 = 45
        self.squares = list()
        self.coordinates = list()
        for char in self.challenge.word:
            if char != ' ':
                self.squares.append(self.word_canvas.create_rectangle(x0, 25, x1, 45, fill='yellow'))
                self.coordinates.append(x0)
            x0 += 30
            x1 += 30

    def validate_guess(self):  # Function to validate the player's guess
        letter = self.letter_entry.get()
        if len(letter) > 1:
            self.root_msg = Tk()
            self.root_msg.withdraw()
            self.root_msg.after(2000, self.root_msg.destroy)
            Message(master=self.root_msg, message='ENTER ONLY ONE LETTER!').show()
        elif not letter.isalpha() and letter != '-':
            self.root_msg = Tk()
            self.root_msg.withdraw()
            self.root_msg.after(2000, self.root_msg.destroy)
            Message(master=self.root_msg, message='ENTER ONLY LETTERS OR HYPHEN (-)!').show()
        elif letter in self.challenge.shadow:
            self.root_msg = Tk()
            self.root_msg.withdraw()
            self.root_msg.after(2000, self.root_msg.destroy)
            Message(master=self.root_msg, message='CHARACTER ALREADY CHOSEN!').show()
        else:
            letter = letter.lower()
            letter = unicodedata.normalize("NFD", letter)
            letter = letter.encode("ascii", "ignore")
            letter = letter.decode("utf-8")
            self.letter_entry.delete(0, END)
            self.attempts += self.check_letter(letter, self.challenge, self.challenge.shadow)
            if self.check_letter(letter, self.challenge, self.challenge.shadow) == -1:
                self.challenge.errors.append(letter)
                ', '.join(str(self.challenge.errors))
            print(self.challenge.shadow)
            print(self.challenge.errors)
        self.letter_entry.delete(0, END)

    @staticmethod
    def check_letter(letter, reference, target):  # Function to compare the guessed letter with the challenge word
        penalty = 0
        if letter in reference.reference:
            for i in range(0, len(reference.reference)):
                if letter == reference.reference[i]:
                    target[i] = reference.word[i]
        else:
            penalty = -1
        return penalty

    def new_game(self, challenge):  # Function to create a new game, setting variables to their initial state according to the challenge object
        self.challenge = challenge  # Variable receiving a challenge object
        self.attempts = 5  # Variable regulating user attempts

        # Visual element for the theme of the game
        self.theme_label = Label(self.word_frame, text='Theme: ' + self.challenge.theme, fg='black')
        self.theme_label.place(x=330, y=50)
        self.change_hangman()
        self.generate_squares()

    def change_hangman(self):  # Function to change the hangman drawing based on attempts or new game
        hangman_images = [ImageTk.PhotoImage(Image.open(f'Forca/IMG/Forca{i}.jpg')) for i in range(6)]

        self.hangman_image = self.canvas.create_image(0, 0, anchor=NW, image=hangman_images[5 - self.attempts])

    def update_word(self):  # Function to reveal letters in the word
        for i in range(len(self.challenge.shadow)):
            if self.challenge.shadow[i] not in ' _':
                self.squares[i] = Label(self.word_canvas, text=self.challenge.word[i])
                self.squares[i].place(x=self.coordinates[i], y=25, width=20, height=20)

    def restart(self):  # Function to restart the game
        self.reset_frames()
        self.new_game(self.database.generate_challenge())

    def update_errors(self):  # Function to update the error box display
        self.error_box.destroy()
        self.error_box = Label(self.errors_frame, text=self.challenge.errors)
        self.error_box.place(relx=0.05, rely=0.1, relheight=0.8, relwidth=0.9)

    def check_win(self):  # Function to check for game end conditions
        if self.attempts == 0:
            self.menu_frame.destroy()
            self.menu_frame = Frame(self.root, highlightbackground="#759fe6", highlightthickness=2)
            self.menu_frame.place(y=300, x=450, width=250, height=175)
            self.win_label = Label(self.menu_frame, text='You lose!', fg='Red')
            self.win_label.pack()
            self.new_game_button_mf = Button(self.menu_frame, text='New Game', command=self.restart, border=2.5, bg="#187db2", fg="#dddddd", font=('verdana', 8, 'bold'), activebackground='#188ecb', activeforeground='white')
            self.new_game_button_mf.place(x=155, y=120, width=70, height=25)
            self.exit_button = Button(self.menu_frame, text='Exit', command=self.exit_game, border=2.5, bg="#187db2", fg="#dddddd", font=('verdana', 8, 'bold'), activebackground='#188ecb', activeforeground='white')
            self.exit_button.place(x=10, y=120, width=70, height=25)

        if ''.join(self.challenge.shadow) == self.challenge.word:
            self.menu_frame.destroy()
            self.menu_frame = Frame(self.root, highlightbackground="#759fe6", highlightthickness=2)
            self.menu_frame.place(y=300, x=450, width=250, height=175)
            self.win_label = Label(self.menu_frame, text='You win!', fg='Green')
            self.win_label.pack()
            self.new_game_button_mf = Button(self.menu_frame, text='New Game', command=self.restart, border=2.5, bg="#187db2", fg="#dddddd", font=('verdana', 8, 'bold'), activebackground='#188ecb', activeforeground='white')
            self.new_game_button_mf.place(x=155, y=120, width=70, height=25)
            self.exit_button = Button(self.menu_frame, text='Exit', command=self.exit_game, border=2.5, bg="#187db2", fg="#dddddd", font=('verdana', 8, 'bold'), activebackground='#188ecb', activeforeground='white')
            self.exit_button.place(x=10, y=120, width=70, height=25)

    def reset_frames(self):  # Function to reset game frames
        self.errors_frame.destroy()
        self.hangman_frame.destroy()
        self.menu_frame.destroy()
        self.word_frame.destroy()
        self.frames()
        self.widgets_hangman_frame()
        self.widgets_menu_frame()
        self.widgets_word_frame()
        self.widgets_errors_frame()

    def attempt(self):  # Function to handle a guess attempt
        self.validate_guess()
        self.change_hangman()
        self.update_errors()
        self.update_word()
        self.check_win()

class Application(Challenge, Functions):  # Class structuring the graphical interface and assigning functions to each part
    
    def __init__(self):
        self.root = root
        self.screen()
        self.frames()
        self.widgets_hangman_frame()
        self.widgets_menu_frame()
        self.widgets_word_frame()
        self.widgets_errors_frame()
        self.initial_screen()
        root.mainloop()

    def screen(self):  # Function to define the graphical interface window
        self.root.title('Hangman')
        self.root.configure(background="#dfe3ee")
        self.root.geometry('1000x500')
        self.root.resizable(False, False)

    def frames(self):  # Defines the divisions (frames) on the game screen
        self.hangman_frame = Frame(self.root)
        self.hangman_frame.place(y=25, x=725, width=250, height=450)
        self.errors_frame = Frame(self.root, bg='#ffffff', highlightbackground="#759fe6", highlightthickness=2)
        self.errors_frame.place(y=300, x=25, width=400, height=175)
        self.word_frame = Frame(self.root, highlightthickness=2)
        self.word_frame.place(y=25, x=25, width=675, height=250)
        self.menu_frame = Frame(self.root, highlightbackground="#759fe6", highlightthickness=2)
        self.menu_frame.place(y=300, x=450, width=250, height=175)

    def widgets_hangman_frame(self):  # Function to display the hangman drawing
        self.canvas = Canvas(self.hangman_frame, bg='white', width=250, height=450)
        self.canvas.place(relx=0, rely=0, relheight=1, relwidth=1)
        self.hangman = ImageTk.PhotoImage(Image.open('Forca/IMG/Forca0.jpg'))
        self.hangman_image = self.canvas.create_image(0, 0, anchor=NW, image=self.hangman)

    def widgets_menu_frame(self):  # Function to define the menu widgets where the user makes their attempts
        self.letter_entry = Entry(self.menu_frame, bg="#dddddd", fg="Black")
        self.letter_entry.place(x=125, y=120, height=20, width=20)
        self.attempt_label = Label(self.menu_frame, text='Enter your guess:', fg='black')
        self.attempt_label.place(x=10, y=120, height=20)
        self.attempt_button = Button(self.menu_frame, text='Try', command=self.attempt, border=2.5, bg="#187db2", fg="#dddddd", font=('verdana', 8, 'bold'), activebackground='#188ecb', activeforeground='white')
        self.attempt_button.place(x=155, y=120, width=55, height=20)

    def widgets_word_frame(self):  # Function to create elements within the word_frame
        self.word_canvas = Canvas(self.word_frame, bg='blue')
        self.word_canvas.place(relx=0, rely=0.5, relwidth=1, relheight=0.5)

    def widgets_errors_frame(self):  # Function to create elements within the errors_frame
        self.error_box = Label(self.errors_frame, text='')
        self.error_box.place(relx=0.05, rely=0.1, relheight=0.8, relwidth=0.9)

    def initial_screen(self):  # Function to generate an initial menu screen
        def change_screen():
            self.initial_frame.destroy()
            self.new_game(self.database.generate_challenge())

        message, validity = check_file('Forca/Biblio.txt')

        self.initial_frame = Frame(self.root)
        self.initial_frame.place(y=0, x=0, width=1000, height=500)

        self.exit_button_mp = Button(self.initial_frame, text='Exit', command=self.exit_game, border=2.5, bg="#187db2", fg="#dddddd", font=('verdana', 10, 'bold'), activebackground='#188ecb',  activeforeground='white')
        self.exit_button_mp.place(x=450, y=400, width=100, height=30)

        self.canvas_thumb = Canvas(self.initial_frame, bg='white', width=800, height=280)
        self.canvas_thumb.place(x=100, y=50)
        self.img_thumb = PhotoImage(Image.open('Forca/IMG/thumb_en.png'))  
        self.thumb = self.canvas_thumb.create_image(0, 0, anchor=NW, image=self.img_thumb)

        if validity:
            self.new_game_button_mp = Button(self.initial_frame, text='New Game', command=change_screen, border=2.5, bg="#187db2", fg="#dddddd", font=('verdana', 8, 'bold'), activebackground='#188ecb', activeforeground='white')
            self.new_game_button_mp.place(x=450, y=350, width=100, height=30)
            self.file_ok_label = Label(self.initial_frame, text=message, font=('verdana', 8, 'bold'), fg='green')
            self.file_ok_label.place(x=350, y=450, width=300)
            self.database = Database('Forca/Biblio.txt')
        else:
            self.error_file_label = Label(self.initial_frame, text=message, font=('verdana', 8, 'bold'), fg='red')
            self.error_file_label.place(x=350, y=300, width=300)

Application()

# File "Biblio.txt" Requirements:
# The file must not be empty and must not contain blank lines.
# It should have themes with a corresponding list of words and vice versa.
# It should not contain non-alphabetic characters except for hashtag, commas, and spaces.
# Each line should contain a single theme and its respective list of words.
# The theme name should be announced first, followed by a # separator, then the list of words.
# Words within a theme should be separated by commas without any preceding or trailing spaces.
